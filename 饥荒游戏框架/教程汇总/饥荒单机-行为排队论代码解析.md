## 封装原函数

`modmain.lua`文件中首先在`AddSimPostInit`函数中给角色绑定了**actionqueuer**组件，并使用一组如下代码对游戏源码中的函数(这里以`OnControl`为例)进行封装,目的是在保证原有函数正常运行的前提下加入自己的修改。

```lua
pc.OnControl = (function()
			local OnControl = pc.OnControl

			return function(self, ...)
				if not (SELECTION_BOX_MODIFIER and _G.TheInput:IsKeyDown(SELECTION_BOX_MODIFIER)) and not (CHERRY_PICKING_MODIFIER and _G.TheInput:IsKeyDown(CHERRY_PICKING_MODIFIER)) then
					return OnControl(self, ...)
				end
			end
		end)()
```

**小记**  
上述代码使用的原理是**lua中函数是第一类值**。

```lua
local function test(x)
	print("test")
	return x+1
end

--[[
1. 定义匿名函数后，匿名函数函数体使用圆括号括起来，再跟一对圆括号表示立即调用匿名函数，见下述例子func_1;
2. 使用一个变量接收匿名函数的执行结果，匿名函数返回函数则变量为函数类型，见func函数；
3. func函数表示一个调用test函数并返回test执行结果的函数
--]]
func = (function()
			print("func_1")
			return function()
				print("func_2")
				return test(1)
			end
		end
)()
```

## 组件

1. **inventory**组件通常被用于生物,其中的一个用法是`inst.components.inventory:GetActiveItem()`获取附着在鼠标上的物品。
2. **stackable**组件通常被用于物品，其中`StackSize()`函数可以获取该物品的当前堆叠值。

## 具体流程

1. 在`ActionQueuer`类的构造函数中会创建一个隐藏的选择窗口作为HUD的子窗口，然后为鼠标左键和右键分别配置一个按键管理;同时还初始化了鼠标左右键按下、弹起和鼠标移动的处理，原因是`TheFrontEnd`当前顶层窗口可能不存在`OnMouseButton()`函数，这样就会导致无法处理鼠标按下或者移动不响应，所以重写`TheFrontEnd:OnMouseButton()`函数将可以自定义自己的鼠标相关的事件。最后，虽然`ActionQueuer`类构造函数中使用`DoTaskInTime()`函数循环执行初始化，但是只要当前inst中已经函数组件`actionqueuer`就不再会在每次循环开始直接返回(考虑是否可以优化，只进行一次初始化)。
